<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>打砖块 / Breakout</title>
  <style>
    :root {
      --bg-1: #0b1021;
      --bg-2: #15254a;
      --panel: rgba(255, 255, 255, 0.1);
      --text: #e7f0ff;
      --accent: #45d0ff;
      --accent-2: #8bff7a;
      --danger: #ff7b8a;
      --shadow: 0 12px 30px rgba(0, 0, 0, 0.35);
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      min-height: 100vh;
      font-family: "Segoe UI", "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei", sans-serif;
      color: var(--text);
      background:
        radial-gradient(circle at 20% 20%, rgba(69, 208, 255, 0.16), transparent 42%),
        radial-gradient(circle at 80% 30%, rgba(139, 255, 122, 0.14), transparent 40%),
        linear-gradient(135deg, var(--bg-1), var(--bg-2));
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 16px;
    }

    .game-wrap {
      width: min(920px, 100%);
      background: var(--panel);
      border: 1px solid rgba(255, 255, 255, 0.18);
      border-radius: 18px;
      backdrop-filter: blur(8px);
      box-shadow: var(--shadow);
      padding: 14px;
    }

    .topbar {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 10px;
    }

    .title { font-size: 1.1rem; font-weight: 700; letter-spacing: 0.4px; }

    .controls {
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
    }

    button, .back-link {
      border: 1px solid rgba(255, 255, 255, 0.22);
      background: rgba(255, 255, 255, 0.08);
      color: var(--text);
      border-radius: 10px;
      padding: 8px 12px;
      font-size: 0.92rem;
      cursor: pointer;
      text-decoration: none;
      transition: transform 0.15s ease, background 0.2s ease;
    }

    button:hover, .back-link:hover {
      transform: translateY(-1px);
      background: rgba(255, 255, 255, 0.15);
    }

    .stats {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      margin-bottom: 10px;
    }

    .pill {
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.15);
      border-radius: 999px;
      padding: 6px 10px;
      font-size: 0.9rem;
    }

    .canvas-shell {
      position: relative;
      width: 100%;
      aspect-ratio: 16 / 10;
      border-radius: 12px;
      overflow: hidden;
      border: 1px solid rgba(255, 255, 255, 0.2);
      background: linear-gradient(180deg, #0d1733, #131f44 45%, #0f1835);
    }

    canvas {
      width: 100%;
      height: 100%;
      display: block;
    }

    .overlay {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      text-align: center;
      padding: 18px;
      background: rgba(7, 12, 27, 0.45);
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.2s ease;
    }

    .overlay.show { opacity: 1; }

    .overlay-box {
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 14px;
      padding: 16px 18px;
      max-width: 420px;
      box-shadow: var(--shadow);
    }

    .overlay h2 { margin: 0 0 8px; }
    .overlay p { margin: 0; line-height: 1.45; }

    .hint {
      margin-top: 10px;
      font-size: 0.86rem;
      color: rgba(231, 240, 255, 0.85);
    }

    @media (max-width: 640px) {
      .game-wrap { padding: 10px; border-radius: 12px; }
      .topbar { gap: 8px; }
      button, .back-link { padding: 7px 10px; font-size: 0.86rem; }
      .title { font-size: 1rem; }
      .pill { font-size: 0.82rem; }
    }
  </style>
</head>
<body>
  <div class="game-wrap">
    <div class="topbar">
      <div class="title" id="titleText">打砖块 Breakout</div>
      <div class="controls">
        <button id="langBtn" type="button">EN</button>
        <button id="restartBtn" type="button">重新开始</button>
        <a class="back-link" href="../index.html" id="backLink">返回游戏中心</a>
      </div>
    </div>

    <div class="stats">
      <div class="pill" id="scoreText">分数: 0</div>
      <div class="pill" id="livesText">生命: 3</div>
      <div class="pill" id="statusText">状态: 进行中</div>
    </div>

    <div class="canvas-shell">
      <canvas id="gameCanvas" width="960" height="600"></canvas>
      <div class="overlay" id="overlay">
        <div class="overlay-box">
          <h2 id="overlayTitle">准备开始</h2>
          <p id="overlayDesc">按空格键开始，方向键或鼠标移动挡板。</p>
        </div>
      </div>
    </div>

    <div class="hint" id="hintText">提示：空格暂停/继续，方向键或鼠标移动挡板，清除所有砖块获胜。</div>
  </div>

  <script>
    (function() {
      const canvas = document.getElementById('gameCanvas');
      const ctx = canvas.getContext('2d');
      const overlay = document.getElementById('overlay');
      const overlayTitle = document.getElementById('overlayTitle');
      const overlayDesc = document.getElementById('overlayDesc');
      const scoreText = document.getElementById('scoreText');
      const livesText = document.getElementById('livesText');
      const statusText = document.getElementById('statusText');
      const titleText = document.getElementById('titleText');
      const hintText = document.getElementById('hintText');
      const backLink = document.getElementById('backLink');
      const langBtn = document.getElementById('langBtn');
      const restartBtn = document.getElementById('restartBtn');

      const i18n = {
        zh: {
          title: '打砖块 Breakout',
          restart: '重新开始',
          back: '返回游戏中心',
          score: '分数',
          lives: '生命',
          status: '状态',
          running: '进行中',
          paused: '已暂停',
          won: '胜利',
          lost: '失败',
          hint: '提示：空格暂停/继续，方向键或鼠标移动挡板，清除所有砖块获胜。',
          readyTitle: '准备开始',
          readyDesc: '按空格键开始，方向键或鼠标移动挡板。',
          pausedTitle: '游戏暂停',
          pausedDesc: '按空格键继续游戏。',
          wonTitle: '你赢了！',
          wonDesc: '太棒了，砖块已全部清除。按重新开始再来一局。',
          lostTitle: '游戏结束',
          lostDesc: '球掉落到底部。按重新开始再试一次。'
        },
        en: {
          title: 'Breakout 打砖块',
          restart: 'Restart',
          back: 'Back to Game Hub',
          score: 'Score',
          lives: 'Lives',
          status: 'Status',
          running: 'Running',
          paused: 'Paused',
          won: 'Won',
          lost: 'Lost',
          hint: 'Tip: Press Space to pause/resume. Use arrows or mouse to move the paddle. Clear all bricks to win.',
          readyTitle: 'Ready',
          readyDesc: 'Press Space to start. Use arrow keys or mouse to move the paddle.',
          pausedTitle: 'Paused',
          pausedDesc: 'Press Space to continue.',
          wonTitle: 'You Win!',
          wonDesc: 'Great job! All bricks are cleared. Press Restart to play again.',
          lostTitle: 'Game Over',
          lostDesc: 'The ball fell below the paddle. Press Restart to try again.'
        }
      };

      let lang = 'zh';

      const game = {
        paddle: {
          w: 150,
          h: 16,
          x: canvas.width / 2 - 75,
          y: canvas.height - 42,
          speed: 10,
          movingLeft: false,
          movingRight: false
        },
        ball: {
          x: canvas.width / 2,
          y: canvas.height - 68,
          r: 10,
          dx: 4,
          dy: -4,
          max: 8
        },
        bricks: {
          rows: 6,
          cols: 10,
          w: 80,
          h: 24,
          pad: 10,
          top: 68,
          left: 25,
          items: []
        },
        score: 0,
        lives: 3,
        state: 'ready'
      };

      function initBricks() {
        const arr = [];
        for (let r = 0; r < game.bricks.rows; r++) {
          for (let c = 0; c < game.bricks.cols; c++) {
            arr.push({
              x: game.bricks.left + c * (game.bricks.w + game.bricks.pad),
              y: game.bricks.top + r * (game.bricks.h + game.bricks.pad),
              alive: true,
              hp: r < 2 ? 2 : 1,
              hue: 190 + r * 18 + c * 1.2
            });
          }
        }
        game.bricks.items = arr;
      }

      function resetBallAndPaddle() {
        game.paddle.x = canvas.width / 2 - game.paddle.w / 2;
        game.ball.x = game.paddle.x + game.paddle.w / 2;
        game.ball.y = game.paddle.y - game.ball.r - 2;
        game.ball.dx = (Math.random() > 0.5 ? 1 : -1) * 4;
        game.ball.dy = -4;
      }

      function resetGame() {
        game.score = 0;
        game.lives = 3;
        game.state = 'ready';
        initBricks();
        resetBallAndPaddle();
        updateTexts();
        showOverlay(i18n[lang].readyTitle, i18n[lang].readyDesc);
      }

      function updateTexts() {
        const t = i18n[lang];
        titleText.textContent = t.title;
        restartBtn.textContent = t.restart;
        backLink.textContent = t.back;
        langBtn.textContent = lang === 'zh' ? 'EN' : '中';
        scoreText.textContent = t.score + ': ' + game.score;
        livesText.textContent = t.lives + ': ' + game.lives;

        let stateText = t.running;
        if (game.state === 'paused' || game.state === 'ready') stateText = t.paused;
        if (game.state === 'won') stateText = t.won;
        if (game.state === 'lost') stateText = t.lost;
        statusText.textContent = t.status + ': ' + stateText;
        hintText.textContent = t.hint;
      }

      function showOverlay(title, desc) {
        overlayTitle.textContent = title;
        overlayDesc.textContent = desc;
        overlay.classList.add('show');
      }

      function hideOverlay() {
        overlay.classList.remove('show');
      }

      function drawBackgroundGrid() {
        ctx.save();
        ctx.globalAlpha = 0.08;
        ctx.strokeStyle = '#9ac8ff';
        ctx.lineWidth = 1;
        for (let x = 0; x < canvas.width; x += 32) {
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, canvas.height);
          ctx.stroke();
        }
        for (let y = 0; y < canvas.height; y += 32) {
          ctx.beginPath();
          ctx.moveTo(0, y);
          ctx.lineTo(canvas.width, y);
          ctx.stroke();
        }
        ctx.restore();
      }

      function roundRect(context, x, y, w, h, r, fill) {
        context.beginPath();
        context.moveTo(x + r, y);
        context.lineTo(x + w - r, y);
        context.quadraticCurveTo(x + w, y, x + w, y + r);
        context.lineTo(x + w, y + h - r);
        context.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
        context.lineTo(x + r, y + h);
        context.quadraticCurveTo(x, y + h, x, y + h - r);
        context.lineTo(x, y + r);
        context.quadraticCurveTo(x, y, x + r, y);
        context.closePath();
        context.fillStyle = fill;
        context.fill();
      }

      function drawPaddle() {
        const p = game.paddle;
        const grd = ctx.createLinearGradient(p.x, p.y, p.x, p.y + p.h);
        grd.addColorStop(0, '#8bff7a');
        grd.addColorStop(1, '#39b95f');
        ctx.save();
        ctx.shadowColor = 'rgba(139, 255, 122, 0.55)';
        ctx.shadowBlur = 15;
        roundRect(ctx, p.x, p.y, p.w, p.h, 8, grd);
        ctx.restore();
      }

      function drawBall() {
        const b = game.ball;
        const g = ctx.createRadialGradient(b.x - 2, b.y - 3, 2, b.x, b.y, b.r + 2);
        g.addColorStop(0, '#ffffff');
        g.addColorStop(1, '#45d0ff');
        ctx.save();
        ctx.shadowColor = 'rgba(69, 208, 255, 0.7)';
        ctx.shadowBlur = 14;
        ctx.beginPath();
        ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2);
        ctx.fillStyle = g;
        ctx.fill();
        ctx.restore();
      }

      function drawBricks() {
        game.bricks.items.forEach(function(brick) {
          if (!brick.alive) return;
          const alpha = brick.hp === 2 ? 0.96 : 0.84;
          const colorTop = 'hsla(' + brick.hue + ', 95%, 66%, ' + alpha + ')';
          const colorBottom = 'hsla(' + (brick.hue - 12) + ', 90%, 44%, ' + alpha + ')';
          const gradient = ctx.createLinearGradient(brick.x, brick.y, brick.x, brick.y + brick.h);
          gradient.addColorStop(0, colorTop);
          gradient.addColorStop(1, colorBottom);
          roundRect(ctx, brick.x, brick.y, game.bricks.w, game.bricks.h, 6, gradient);

          if (brick.hp === 2) {
            ctx.save();
            ctx.fillStyle = 'rgba(255,255,255,0.45)';
            ctx.fillRect(brick.x + 8, brick.y + 8, game.bricks.w - 16, 3);
            ctx.restore();
          }
        });
      }

      function clampBallSpeed() {
        const b = game.ball;
        b.dx = Math.max(-b.max, Math.min(b.max, b.dx));
        b.dy = Math.max(-b.max, Math.min(b.max, b.dy));
      }

      function collideBricks() {
        const b = game.ball;
        for (let i = 0; i < game.bricks.items.length; i++) {
          const brick = game.bricks.items[i];
          if (!brick.alive) continue;

          if (
            b.x + b.r > brick.x &&
            b.x - b.r < brick.x + game.bricks.w &&
            b.y + b.r > brick.y &&
            b.y - b.r < brick.y + game.bricks.h
          ) {
            const prevX = b.x - b.dx;
            const prevY = b.y - b.dy;
            const hitFromSide = prevX <= brick.x || prevX >= brick.x + game.bricks.w;
            const hitFromTopBottom = prevY <= brick.y || prevY >= brick.y + game.bricks.h;

            if (hitFromSide) b.dx = -b.dx;
            if (hitFromTopBottom || !hitFromSide) b.dy = -b.dy;

            brick.hp -= 1;
            if (brick.hp <= 0) {
              brick.alive = false;
              game.score += 10;
            } else {
              game.score += 4;
            }

            if (Math.abs(b.dy) < b.max) {
              b.dy += b.dy > 0 ? 0.06 : -0.06;
            }
            clampBallSpeed();
            break;
          }
        }
      }

      function checkWin() {
        return game.bricks.items.every(function(b) { return !b.alive; });
      }

      function updateGame() {
        if (game.state !== 'running') return;

        const p = game.paddle;
        const b = game.ball;

        if (p.movingLeft) p.x -= p.speed;
        if (p.movingRight) p.x += p.speed;
        p.x = Math.max(0, Math.min(canvas.width - p.w, p.x));

        b.x += b.dx;
        b.y += b.dy;

        if (b.x - b.r <= 0 || b.x + b.r >= canvas.width) {
          b.dx = -b.dx;
        }
        if (b.y - b.r <= 0) {
          b.dy = -b.dy;
        }

        if (
          b.x + b.r > p.x &&
          b.x - b.r < p.x + p.w &&
          b.y + b.r > p.y &&
          b.y - b.r < p.y + p.h &&
          b.dy > 0
        ) {
          const hitPoint = (b.x - (p.x + p.w / 2)) / (p.w / 2);
          b.dx = hitPoint * 6;
          b.dy = -Math.max(3.6, Math.abs(b.dy));
          b.y = p.y - b.r - 1;
          clampBallSpeed();
        }

        collideBricks();

        if (b.y - b.r > canvas.height) {
          game.lives -= 1;
          if (game.lives <= 0) {
            game.state = 'lost';
            showOverlay(i18n[lang].lostTitle, i18n[lang].lostDesc);
          } else {
            game.state = 'paused';
            resetBallAndPaddle();
            showOverlay(i18n[lang].readyTitle, i18n[lang].readyDesc);
          }
        }

        if (checkWin()) {
          game.state = 'won';
          showOverlay(i18n[lang].wonTitle, i18n[lang].wonDesc);
        }
      }

      function render() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawBackgroundGrid();
        drawBricks();
        drawPaddle();
        drawBall();
        updateTexts();
      }

      function loop() {
        updateGame();
        render();
        requestAnimationFrame(loop);
      }

      function setRunning() {
        if (game.state === 'won' || game.state === 'lost') return;
        game.state = 'running';
        hideOverlay();
      }

      window.addEventListener('keydown', function(e) {
        if (e.key === 'ArrowLeft') game.paddle.movingLeft = true;
        if (e.key === 'ArrowRight') game.paddle.movingRight = true;
        if (e.code === 'Space') {
          e.preventDefault();
          if (game.state === 'running') {
            game.state = 'paused';
            showOverlay(i18n[lang].pausedTitle, i18n[lang].pausedDesc);
          } else if (game.state === 'paused' || game.state === 'ready') {
            setRunning();
          }
        }
      });

      window.addEventListener('keyup', function(e) {
        if (e.key === 'ArrowLeft') game.paddle.movingLeft = false;
        if (e.key === 'ArrowRight') game.paddle.movingRight = false;
      });

      canvas.addEventListener('mousemove', function(e) {
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const scaledX = (x / rect.width) * canvas.width;
        game.paddle.x = scaledX - game.paddle.w / 2;
        game.paddle.x = Math.max(0, Math.min(canvas.width - game.paddle.w, game.paddle.x));

        if (game.state === 'ready' || game.state === 'paused') {
          game.ball.x = game.paddle.x + game.paddle.w / 2;
        }
      });

      canvas.addEventListener('click', function() {
        if (game.state === 'ready' || game.state === 'paused') {
          setRunning();
        }
      });

      langBtn.addEventListener('click', function() {
        lang = lang === 'zh' ? 'en' : 'zh';
        if (game.state === 'ready') {
          showOverlay(i18n[lang].readyTitle, i18n[lang].readyDesc);
        } else if (game.state === 'paused') {
          showOverlay(i18n[lang].pausedTitle, i18n[lang].pausedDesc);
        } else if (game.state === 'won') {
          showOverlay(i18n[lang].wonTitle, i18n[lang].wonDesc);
        } else if (game.state === 'lost') {
          showOverlay(i18n[lang].lostTitle, i18n[lang].lostDesc);
        }
        updateTexts();
      });

      restartBtn.addEventListener('click', resetGame);

      resetGame();
      render();
      requestAnimationFrame(loop);
    })();
  </script>
</body>
</html>
